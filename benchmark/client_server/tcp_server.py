#!/usr/bin/env python

from time import sleep
import subprocess32 as subprocess
import socket
import json
import sys

# path to the benchmark config json file (generated by the benchmark_gen.py)
BENCH_CONFIG_FILE = 'benchmark.json'

# benchmark's one pass time in seconds
BENCH_TIME = 100

# socket buffer size
BUFFER_SIZE = 1024

# socket bind IP + port
HOST_PORT = ('0.0.0.0', 15555)

# video streaming server start command pattern
SERVER_START_CMD_PATTERN = "../build/RTSPServer --trial={} --out-width={} --out-height={}" \
                           " --vbv-bufsize={} --udp={} --bitrate={} --out-fps={}"

# client benchmark start command pattern
CLIENT_CMD_PATTERN = 'openRTSP -V -f {} -w {} -h {} -Q -n -d {} -F trial_{}_<replace>_ rtsp://10.42.0.1:8554/<replace>'


# sets socket options to keep connection alive
def set_keep_alive(sock, after_idle_sec=30, interval_sec=10, max_fails=10):
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, after_idle_sec)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, interval_sec)
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, max_fails)


# waits for any data to come from client
def wait_for_data(sock, sleep_sec=1):
    data = ''
    while data == '':
        data = sock.recv(BUFFER_SIZE)
        sleep(sleep_sec)
    return data


# loads benchmark's configuration file (json)
def load_test_config(filename):
    with open(filename) as infile:
        return json.load(infile)


# binds socket to the specified host:port
def bind_sock(sock, host_port=HOST_PORT):
    try:
        sock.bind(host_port)
    except socket.error as err:
        print "Bind failed. Error code : " + str(err)
        sys.exit()


if __name__ == "__main__":

    # load benchmark's params
    trials = load_test_config(BENCH_CONFIG_FILE)

    # create a server socket
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # bind a socket to the address
    bind_sock(server_socket)

    set_keep_alive(server_socket)

    # start listening on the specified port
    server_socket.listen(1)

    print "Socket is listening..."

    # wait for clients
    client_connection, addr = server_socket.accept()

    print "Client has connected: ", str(addr)

    # open the log file
    with open('server_output.log', 'wb') as logfile:

        for trial in trials['benchmark']:

            try:

                server_cmd = SERVER_START_CMD_PATTERN.format(trial['trial'], trial['width'], trial['height'],
                                                             trial['buf_size'], trial['datagram_size'],
                                                             trial['bit_rate'], trial['frame_rate'])

                print "Starting the server... : '{}'".format(server_cmd)

                # open the server process with the specified logfile
                video_server_process = subprocess.Popen(server_cmd.split(), stdout=logfile, stderr=logfile)

                sleep(5)

                # try to restart server
                while video_server_process.poll() is not None:
                    print "Trying to restart RTSP server ..."
                    video_server_process = subprocess.Popen(server_cmd.split(), stdout=logfile, stderr=logfile)
                    sleep(5)

                print "Video server is ready to serve clients!"

                client_cmd = CLIENT_CMD_PATTERN.format(trial['frame_rate'], trial['width'], trial['height'], BENCH_TIME,
                                                       trial['trial'])

                print "Sending command to client: {}".format(client_cmd)

                client_connection.sendall(client_cmd)

                print "Waiting for client's cmd to stop the server ..."

                client_data = wait_for_data(client_connection)

                # stop the server
                video_server_process.terminate()

                video_server_process.wait()

            except socket.error:
                print "Error occurred:", str(socket.error)
                break

    # send a kill cmd to the client to be stopped
    client_connection.sendall("KILL")

    # wait for the client to stop
    sleep(10)

    # close resources
    client_connection.close()
    server_socket.close()
